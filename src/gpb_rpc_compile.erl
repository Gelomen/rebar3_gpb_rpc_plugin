-module(gpb_rpc_compile).
-include_lib("gpb/include/gpb.hrl").

-define(input_data(Cmd, CCmd, Input, InputUpper, Func, BaseData),
    [
        {cmd, Cmd}, {ccmd, CCmd},
        {msg, Input}, {msg_upper, InputUpper},
        {handle_func, Func} | BaseData
    ]).

-define(output_data(Cmd, CCmd, Output, OutputUpper, BaseData),
    [
        {cmd, Cmd}, {ccmd, CCmd}, {msg, Output},
        {msg_upper, OutputUpper} | BaseData
    ]).

-define(AUTO_GEN_HEAD,
    <<"%% -*- coding: utf-8 -*-\n%% Automatically generated, do not edit\n%% Generated by gpb_rpc_compile\n">>).

%% API
-export([
    gen_router/4,
    file/5
]).

gen_router(AppDir, RouterFile, GpbRpcOpts, GpbOpts) ->
    RpcModuleNameSuffix = proplists:get_value(module_name_suffix, GpbRpcOpts),
    RouterFile0 = filename:basename(RouterFile, ".proto") ++ RpcModuleNameSuffix,
    ModuleNameSuffix = proplists:get_value(module_name_suffix, GpbOpts),
    SourceDirs = proplists:lookup_all(i, GpbRpcOpts),
    PrefixLen = length(proplists:get_value(msg_prefix, GpbRpcOpts)),
    ModPrefix = proplists:get_value(mod_prefix, GpbRpcOpts),
    CCmdBit = proplists:get_value(ccmd_bit, GpbRpcOpts),

    {ok, RouterDefines} = to_proto_defines(filename:join([AppDir, RouterFile]), SourceDirs, GpbOpts),
    {_, RouterCmds} = hd([{EnumName, EnumList} || {{enum, EnumName}, EnumList} <- RouterDefines]),

    IsSnakeCase = proplists:is_defined(msg_name_to_snake_case, GpbOpts),

    #{input_list := InputList0, output_list := OutputList0, router_cmd_list := RouterCmdList} = lists:foldl(
        fun({ModCmd, RouterCmd}, #{router_cmd_list := RouterCmdListT} = Acc) ->
            ProtoName = atom_to_list(ModCmd),
            case find_proto_file(AppDir, ProtoName, SourceDirs, GpbOpts) of
                [{_, Defines} | _] ->
                    RouterCmdTerm = [{cmd_name, ModCmd}, {cmd, RouterCmd}],
                    gen_router_do(ProtoName, RouterCmd, Defines, RpcModuleNameSuffix, ModuleNameSuffix,
                        PrefixLen, ModPrefix, CCmdBit, IsSnakeCase,
                        Acc#{router_cmd_list => [RouterCmdTerm | RouterCmdListT]});
                false ->
                    rebar_utils:abort("router:~ts.proto have define ~p, but no find ~p.proto file",
                        [RouterFile0, ModCmd, ModCmd])
            end
        end, #{input_list => [], output_list => [], output_names => [], router_cmd_list => []}, RouterCmds),

    InputList = lists:reverse(InputList0),
    OutputList = lists:reverse(OutputList0),

    TargetErlDir = proplists:get_value(o_erl, GpbRpcOpts),
    ErlTarget = filename:join([TargetErlDir, RouterFile0 ++ ".erl"]),
    RouterErlTplFile0 = proplists:get_value(router_erl_tpl, GpbRpcOpts),
    RouterErlTplFile = bbmustache:parse_file(filename:join([AppDir, RouterErlTplFile0])),

    CmdList = lists:sort(InputList ++ OutputList),

    ErlRenderData = [
        {file, RouterFile0},
        {file_upper, string:to_upper(RouterFile0)},
        {input_list, add_is_last(InputList)},
        {output_list, add_is_last(OutputList)},
        {router_cmd_list, add_is_last(lists:reverse(RouterCmdList))},
        {cmd_list, add_is_last(CmdList)}
    ],
    compile_tpl(ErlTarget, RouterErlTplFile, ErlRenderData),

    HrlRenderData = [
        {file, RouterFile0},
        {file_upper, string:to_upper(RouterFile0)},
        {cmd_list, CmdList},
        {hrl_list, [[{hrl_name, lists:concat([ModCmd, ModuleNameSuffix])}] || {ModCmd, _} <- RouterCmds]}
    ],
    TargetHrlDir = proplists:get_value(o_hrl, GpbRpcOpts),
    HrlTarget = filename:join([TargetHrlDir, RouterFile0 ++ ".hrl"]),
    RouterHrlTplFile0 = proplists:get_value(router_hrl_tpl, GpbRpcOpts),
    RouterHrlTplFile = bbmustache:parse_file(filename:join([AppDir, RouterHrlTplFile0])),
    compile_tpl(HrlTarget, RouterHrlTplFile, HrlRenderData),
    ok.

file(ProtoFile, ErlTpl, HrlTpl, GpbRpcOpts, GpbOpts) ->
    SourceDirs = proplists:lookup_all(i, GpbRpcOpts),
    case to_proto_defines(ProtoFile, SourceDirs, GpbOpts) of
        {ok, Defines} ->
            ProtoName = filename:rootname(filename:basename(ProtoFile)),
            ModuleNameSuffix = proplists:get_value(module_name_suffix, GpbRpcOpts),
            file_do(ProtoName ++ ModuleNameSuffix, ProtoName, ErlTpl, HrlTpl, GpbRpcOpts, GpbOpts, Defines);
        Err -> Err
    end.

file_do(FileName, ProtoName, ErlTpl, HrlTpl, GpbRpcOpts, GpbOpts, Defines) ->
    ModuleNameSuffix = proplists:get_value(module_name_suffix, GpbOpts),
    GpbProto = ProtoName ++ ModuleNameSuffix,

    case {gen_mod(FileName, ProtoName, GpbProto, Defines),
        gen_hrl(FileName, ProtoName, GpbProto, Defines)} of
        {skip, skip} ->
            rebar_api:debug("skipped gen gpb rpc & hrl : ~p", [FileName]);
        {skip, HrlRenderData} ->
            TargetHrlDir = proplists:get_value(o_hrl, GpbRpcOpts),
            HrlTarget = filename:join([TargetHrlDir, FileName ++ ".hrl"]),
            compile_tpl(HrlTarget, HrlTpl, HrlRenderData),

            rebar_api:debug("skipped gen gpb rpc : ~p", [FileName]);
        {ErlRenderData, skip} ->
            rebar_api:debug("skipped gen gpb rpc hrl: ~p", [FileName]),

            TargetErlDir = proplists:get_value(o_erl, GpbRpcOpts),
            ErlTarget = filename:join([TargetErlDir, FileName ++ ".erl"]),
            compile_tpl(ErlTarget, ErlTpl, ErlRenderData);
        {ErlRenderData, HrlRenderData} ->
            TargetHrlDir = proplists:get_value(o_hrl, GpbRpcOpts),
            HrlTarget = filename:join([TargetHrlDir, FileName ++ ".hrl"]),
            compile_tpl(HrlTarget, HrlTpl, HrlRenderData),

            TargetErlDir = proplists:get_value(o_erl, GpbRpcOpts),
            ErlTarget = filename:join([TargetErlDir, FileName ++ ".erl"]),
            compile_tpl(ErlTarget, ErlTpl, ErlRenderData)
    end,
    ok.

compile_tpl(Target, Tpl, RenderData) ->
    IoData = bbmustache:compile(Tpl, RenderData, [{key_type, atom}]),
    ok = file:write_file(Target, [?AUTO_GEN_HEAD, IoData]).

-spec to_proto_defines(ProtoFile :: file:filename(), SourceDirs :: [file:filename()],
    proplists:proplist()) -> {ok, Defines :: tuple()}.
to_proto_defines(ProtoFile, SourceDirs, GpbOpts) ->
    {ok, Binary} = file:read_file(ProtoFile),
    String = binary_to_list(Binary),
    gpb_compile:string(mod, String, [to_proto_defs | SourceDirs] ++ GpbOpts).

gen_mod(FileName, ProtoName, GpbProto, Defines) ->
    Service = list_to_atom(ProtoName ++ "_service"),
    case lists:keyfind({service, Service}, 1, Defines) of
        {_, RpcList} ->
            CallbackList =
                [begin
                     Func = atom_to_list(Func0),
                     Input = atom_to_list(Input0),
                     [
                         {gpb_proto, GpbProto},
                         {callback, Func},
                         {req, Input}
                     ]
                 end || #?gpb_rpc{input = Input0, name = Func0} <- RpcList,
                    Input0 =/= 'Empty' andalso Input0 =/= undefined],
            case CallbackList of
                [] -> skip;
                _ ->
                    [
                        {file, FileName},
                        {gpb_proto, GpbProto},
                        {callback_list, CallbackList}
                    ]
            end;
        false -> skip
    end.

gen_router_do(ProtoName, RouterCmd, Defines, RpcModuleNameSuffix, ModuleNameSuffix,
    PrefixLen, ModPrefix, CCmdBit, IsSnakeCase, Acc0) ->
    Service = list_to_atom(ProtoName ++ "_service"),
    {_, RpcList} = lists:keyfind({service, Service}, 1, Defines),
    {_, CCmdList0} = hd([{EnumName, EnumList} || {{enum, EnumName}, EnumList} <- Defines]),
    GpbProto = ProtoName ++ ModuleNameSuffix,
    HandleMod = ModPrefix ++ string:substr(ProtoName, PrefixLen + 1) ++ RpcModuleNameSuffix,
    ProtoNameUpper = string:to_upper(ProtoName),
    BaseData = [
        {mod_cmd, RouterCmd},
        {mod_cmd_name, ProtoName},
        {mod_cmd_name_upper, ProtoNameUpper},
        {gpb_proto, GpbProto},
        {handle_mod, HandleMod}
    ],
    CCmdList = [
        begin
            NewCCmdName =
                case IsSnakeCase of
                    true ->
                        list_to_atom(gpb_lib:snake_case(atom_to_list(CCmdName)));
                    _ -> CCmdName
                end,
            {NewCCmdName, {CCmd, RouterCmd bsl CCmdBit + CCmd}}
        end || {CCmdName, CCmd} <- CCmdList0],

    lists:foldl(
        fun(Rpc, Acc) ->
            erl_rpc(Rpc, CCmdList, BaseData, Acc)
        end, Acc0, RpcList).

%% Empty for proto3; undefined for proto2
erl_rpc(#?gpb_rpc{input = Input, output = Output0}, CCmdList, BaseData, #{output_names := OutputNames} = Acc)
    when (Input =:= 'Empty' orelse Input =:= undefined)
    andalso Output0 =/= 'Empty' andalso Output0 =/= undefined ->
    Output = atom_to_list(Output0),
    case lists:member(Output0, OutputNames) of
        true -> Acc;
        false ->
            #{output_list := OutputList, output_names := OutputNames} = Acc,
            {CCmd, Cmd} = proplists:get_value(Output0, CCmdList),
            OutputUpper = string:to_upper(Output),
            OutputData = ?output_data(Cmd, CCmd, Output, OutputUpper, BaseData),
            Acc#{
                output_list => [OutputData | OutputList],
                output_names => [Output0 | OutputNames]
            }
    end;
erl_rpc(#?gpb_rpc{name = Func0, input = Input0, output = Output}, CCmdList, BaseData, #{input_list := InputList} = Acc)
    when (Output =:= 'Empty' orelse Output =:= undefined)
    andalso Input0 =/= 'Empty' andalso Input0 =/= undefined ->
    Func = atom_to_list(Func0),
    Input = atom_to_list(Input0),
    InputUpper = string:to_upper(Input),
    {CCmd, Cmd} = proplists:get_value(Input0, CCmdList),
    InputData = ?input_data(Cmd, CCmd, Input, InputUpper, Func, BaseData),
    Acc#{
        input_list => [InputData | InputList]
    };
erl_rpc(#?gpb_rpc{name = Func0, input = Input0, output = Output0}, CCmdList, BaseData,
    #{input_list := InputList, output_list := OutputList, output_names := OutputNames} = Acc)
    when Input0 =/= 'Empty' andalso Input0 =/= undefined
    andalso Output0 =/= 'Empty' andalso Output0 =/= undefined ->
    Func = atom_to_list(Func0),
    Input = atom_to_list(Input0),
    InputUpper = string:to_upper(Input),
    Output = atom_to_list(Output0),
    OutputUpper = string:to_upper(Output),
    {InputCCmd, InputCmd} = proplists:get_value(Input0, CCmdList),
    InputData = ?input_data(InputCmd, InputCCmd, Input, InputUpper, Func, BaseData),
    case lists:member(Output0, OutputNames) of
        true ->
            Acc#{
                input_list => [InputData | InputList],
                output_list=> OutputList,
                output_names => OutputNames
            };
        false ->
            {OutputCCmd, OutputCmd} = proplists:get_value(Output0, CCmdList),
            OutputData = ?output_data(OutputCmd, OutputCCmd, Output, OutputUpper, BaseData),
            Acc#{
                input_list => [InputData | InputList],
                output_list => [OutputData | OutputList],
                output_names => [Output0 | OutputNames]
            }
    end.

%%--------------------------------------------------------------------
gen_hrl(FileName, ProtoName, GpbProto, Defines) ->
    FileNameUpper = string:to_upper(FileName),
    BaseData = [
        {file, FileName},
        {file_upper, FileNameUpper},
        {gpb_proto, GpbProto}
    ],
    Service = list_to_atom(ProtoName ++ "_service"),
    AllEnumList0 = [{EnumName, EnumList} || {{enum, EnumName}, EnumList} <- Defines],

    AllEnumList =
        case lists:keymember({service, Service}, 1, Defines) of
            true ->
                tl(AllEnumList0);
            _ -> AllEnumList0
        end,
    case AllEnumList of
        [] -> skip;
        _ ->
            EnumsList = [hrl_enums_list(EnumName, EnumList, BaseData)
                || {EnumName, EnumList} <- AllEnumList],
            [{enums_list, EnumsList} | BaseData]
    end.
hrl_enums_list(EnumName, EnumList0, BaseData0) ->
    EnumNameUpper = string:to_upper(atom_to_list(EnumName)),
    BaseData = [
        {enum_name, EnumName},
        {enum_name_upper, EnumNameUpper} | BaseData0
    ],
    EnumList = [hrl_enum(EnumKey, EnumValue, BaseData) || {EnumKey, EnumValue} <- EnumList0],
    [
        {enum_list, EnumList} | BaseData
    ].
hrl_enum(EnumKey, EnumValue, BaseData) ->
    EnumKeyUpper = string:to_upper(atom_to_list(EnumKey)),
    [
        {enum_key, EnumKey},
        {enum_key_upper, EnumKeyUpper},
        {enum_value, EnumValue} | BaseData
    ].

add_is_last([]) -> [];
add_is_last(List) ->
    [H | T] = lists:reverse(List),
    lists:reverse([[{is_last, true} | H] | T]).

find_proto_file(AppDir, ProtoName, SourceDirs, GpbOpts) ->
    lists:foldl(
        fun({i, SourceDir}, Acc) ->
            ProtoFile = filename:join([AppDir, SourceDir, ProtoName ++ ".proto"]),
            case filelib:is_file(ProtoFile) of
                true ->
                    {ok, Defines} = to_proto_defines(ProtoFile, SourceDirs, GpbOpts),
                    [{ProtoName, Defines} | Acc];
                false ->
                    Acc
            end
        end, [], SourceDirs).